{
  "contractName": "LiquidStake",
  "constructorInputs": [
    {
      "name": "ownerPkh",
      "type": "bytes20"
    }
  ],
  "abi": [
    {
      "name": "stake",
      "inputs": []
    },
    {
      "name": "unstake",
      "inputs": []
    },
    {
      "name": "withdraw",
      "inputs": [
        {
          "name": "pk",
          "type": "pubkey"
        },
        {
          "name": "s",
          "type": "sig"
        }
      ]
    }
  ],
  "bytecode": "OP_OVER OP_0 OP_NUMEQUAL OP_IF OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_0 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_SUB OP_DUP 1027 OP_GREATERTHANOREQUAL OP_VERIFY OP_0 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_1 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_1 OP_OUTPUTTOKENCOMMITMENT OP_SWAP OP_8 OP_NUM2BIN OP_EQUALVERIFY OP_1 OP_OUTPUTBYTECODE OP_1 OP_UTXOBYTECODE OP_EQUALVERIFY OP_TXOUTPUTCOUNT OP_3 OP_LESSTHANOREQUAL OP_VERIFY OP_TXOUTPUTCOUNT OP_3 OP_NUMEQUAL OP_IF OP_2 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_ENDIF OP_2DROP OP_1 OP_ELSE OP_OVER OP_1 OP_NUMEQUAL OP_IF OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_0 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_1 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_1 OP_UTXOTOKENCOMMITMENT OP_BIN2NUM OP_0 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_ROT OP_SUB OP_GREATERTHANOREQUAL OP_VERIFY OP_1 OP_OUTPUTBYTECODE OP_1 OP_UTXOBYTECODE OP_EQUALVERIFY OP_TXOUTPUTCOUNT OP_2 OP_NUMEQUALVERIFY OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUAL OP_NIP OP_NIP OP_ELSE OP_SWAP OP_2 OP_NUMEQUALVERIFY OP_OVER OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG OP_ENDIF OP_ENDIF",
  "source": "pragma cashscript ^0.12.0;\n\n// LiquidStake — Stake BCH → get lstBCH NFT receipt → unstake with yield\n//\n// The contract holds a minting NFT. On stake, it mints an immutable receipt NFT\n// whose commitment encodes the staked sats amount. On unstake, the receipt NFT\n// is burned and BCH is returned.\n//\n// NFT commitment layout: bytes8(stakedAmount)\n\ncontract LiquidStake(bytes20 ownerPkh) {\n\n    // Stake BCH into the pool and receive an lstBCH receipt NFT.\n    // Input 0: contract UTXO (minting NFT)\n    // Input 1: user's BCH funding input\n    // Output 0: contract UTXO with minting NFT preserved (covenant)\n    // Output 1: receipt NFT sent to user\n    // Output 2: (optional) BCH change back to user\n    function stake() {\n        require(this.activeInputIndex == 0);\n\n        // Covenant: contract bytecode must be preserved\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n\n        // Covenant: minting NFT must be preserved (category + 0x02 capability)\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n\n        // Calculate how much BCH was added to the pool\n        int satsAdded = tx.outputs[0].value - tx.inputs[0].value;\n        require(satsAdded >= 10000);\n\n        // Mint a receipt NFT: same category, no capability (immutable)\n        bytes tokenCategoryReceipt = tx.inputs[0].tokenCategory.split(32)[0];\n        require(tx.outputs[1].tokenCategory == tokenCategoryReceipt);\n\n        // Receipt NFT commitment = staked amount\n        require(tx.outputs[1].nftCommitment == bytes8(satsAdded));\n\n        // Receipt goes to the user (input 1's address)\n        require(tx.outputs[1].lockingBytecode == tx.inputs[1].lockingBytecode);\n\n        // Cap outputs to prevent unauthorized extra minting\n        require(tx.outputs.length <= 3);\n\n        // If there's a change output, it must not carry tokens\n        if (tx.outputs.length == 3) {\n            require(tx.outputs[2].tokenCategory == 0x);\n        }\n    }\n\n    // Unstake: return receipt NFT to get BCH back.\n    // Input 0: contract UTXO (minting NFT)\n    // Input 1: user's receipt NFT\n    // Output 0: contract UTXO with minting NFT preserved (covenant)\n    // Output 1: BCH payout to user (receipt NFT is burned)\n    function unstake() {\n        require(this.activeInputIndex == 0);\n\n        // Covenant: contract bytecode must be preserved\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n\n        // Covenant: minting NFT must be preserved\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n\n        // Validate receipt NFT: same category, no capability suffix (immutable)\n        bytes tokenCategoryReceipt = tx.inputs[0].tokenCategory.split(32)[0];\n        require(tx.inputs[1].tokenCategory == tokenCategoryReceipt);\n\n        // Read staked amount from receipt commitment\n        int stakedAmount = int(tx.inputs[1].nftCommitment);\n\n        // Pool BCH decreases by payout amount\n        require(tx.outputs[0].value >= tx.inputs[0].value - stakedAmount);\n\n        // Payout goes to the receipt holder\n        require(tx.outputs[1].lockingBytecode == tx.inputs[1].lockingBytecode);\n\n        // Only 2 outputs: contract + payout (burns the receipt NFT)\n        require(tx.outputs.length == 2);\n\n        // Burn the receipt: output 1 must carry no tokens\n        require(tx.outputs[1].tokenCategory == 0x);\n    }\n\n    // Owner can withdraw excess / manage the pool\n    function withdraw(pubkey pk, sig s) {\n        require(hash160(pk) == ownerPkh);\n        require(checkSig(s, pk));\n    }\n}\n",
  "debug": {
    "bytecode": "78009c63c0009d00cd00c78800d100ce8800cc00c69476021027a26900ce01207f7551d18851d27c58808851cd51c788c453a169c4539c6352d10088686d516778519c63c0009d00cd00c78800d100ce8800ce01207f7551ce8851cf8100cc00c67b94a26951cd51c788c4529d51d100877777677c529d78a988ac6868",
    "sourceMap": "19:4:49:5;;;;20:16:20:37;:41::42;:8::44:1;23:27:23:28:0;:16::45:1;:59::60:0;:49::77:1;:8::79;26:27:26:28:0;:16::43:1;:57::58:0;:47::73:1;:8::75;29:35:29:36:0;:24::43:1;:56::57:0;:46::64:1;:24;30:16:30:25:0;:29::34;:16:::1;:8::36;33:47:33:48:0;:37::63:1;:70::72:0;:37::73:1;:::76;34:27:34:28:0;:16::43:1;:8::69;37:27:37:28:0;:16::43:1;:54::63:0;:47::64:1;;:8::66;40:27:40:28:0;:16::45:1;:59::60:0;:49::77:1;:8::79;43:16:43:33:0;:37::38;:16:::1;:8::40;46:12:46:29:0;:33::34;:12:::1;:36:48:9:0;47:31:47:32;:20::47:1;:51::53:0;:12::55:1;46:36:48:9;19:4:49:5;;;56::83::0;;;;57:16:57:37;:41::42;:8::44:1;60:27:60:28:0;:16::45:1;:59::60:0;:49::77:1;:8::79;63:27:63:28:0;:16::43:1;:57::58:0;:47::73:1;:8::75;66:47:66:48:0;:37::63:1;:70::72:0;:37::73:1;:::76;67:26:67:27:0;:16::42:1;:8::68;70:41:70:42:0;:31::57:1;:27::58;73::73:28:0;:16::35:1;:49::50:0;:39::57:1;:60::72:0;:39:::1;:16;:8::74;76:27:76:28:0;:16::45:1;:59::60:0;:49::77:1;:8::79;79:16:79:33:0;:37::38;:8::40:1;82:27:82:28:0;:16::43:1;:47::49:0;:8::51:1;56:4:83:5;;;86::89::0;;;87:24:87:26;:16::27:1;:8::41;88::88:33;11:0:90:1;",
    "logs": [],
    "requires": [
      {
        "ip": 7,
        "line": 20
      },
      {
        "ip": 12,
        "line": 23
      },
      {
        "ip": 17,
        "line": 26
      },
      {
        "ip": 26,
        "line": 30
      },
      {
        "ip": 34,
        "line": 34
      },
      {
        "ip": 40,
        "line": 37
      },
      {
        "ip": 45,
        "line": 40
      },
      {
        "ip": 49,
        "line": 43
      },
      {
        "ip": 57,
        "line": 47
      },
      {
        "ip": 68,
        "line": 57
      },
      {
        "ip": 73,
        "line": 60
      },
      {
        "ip": 78,
        "line": 63
      },
      {
        "ip": 86,
        "line": 67
      },
      {
        "ip": 97,
        "line": 73
      },
      {
        "ip": 102,
        "line": 76
      },
      {
        "ip": 105,
        "line": 79
      },
      {
        "ip": 110,
        "line": 82
      },
      {
        "ip": 118,
        "line": 87
      },
      {
        "ip": 120,
        "line": 88
      }
    ]
  },
  "compiler": {
    "name": "cashc",
    "version": "0.12.1"
  },
  "updatedAt": "2026-02-26T11:13:05.034Z"
}